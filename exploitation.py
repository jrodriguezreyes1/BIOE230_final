# this takes in the output of the exploration and optimizes it

import numpy
import exploration
import helpers
import matplotlib.pyplot as plt
from matplotlib import colors

# Simulation Constants (Walker settings in Walker.__init__ function)
num_walkers = 5             # Number of Walkers
x_scaling = 2000            # width of area walkers could be on
nutrient_level = 1500       # point where nutrient is located
max_loops = 10000           # stop the simulation from running away

pressure = 100
	
# all_walkers = exploration.exploitation_algorithm()
# plot = exploration.plot_data(all_walkers)
# exploration.save_data(all_walkers, plot)
all_walkers = helpers.load_exploration("C:\\Users\\couvr\\Documents\\Projects\\Slime_Mold_Simulation\\simulation_software\\raw_data\\07_22_2023_17-46-59\\raw_data.csv")

nodes = []
starting_positions = []
finished_positions = []
central_positions = []
for walker in all_walkers:
	nodes.append(walker.starting_position)
	nodes.append(walker.positions[-1])
	if walker.starting_position[1] == 0:
		starting_positions.append(walker.starting_position)
	else:
		central_positions.append(walker.starting_position)
	if walker.finished:
		finished_positions.append(walker.positions[-1])
	else:
		central_positions.append(walker.positions[-1])

# starting_position_indices = []
# for i in range(len(nodes)):
# 	if nodes[i] in starting_positions:
# 		starting_position_indices.append(i)



L = []
for i in range(len(nodes)):
	
	node1 = nodes[i]
	L.append([0]*len(nodes))

	for walker in all_walkers:
		if node1 in walker.positions:


			# Really need to test the below code...but works for now



			pre_flag = True
			length = 0
			node2 = walker.positions[0]



			for position in walker.positions:
				if position in nodes:
					if position == node1:
						#change flag to after node
						pre_flag = False
						#record length for first
						# print('here: ', length)
						if L[i][nodes.index(node2)] == 0:
							L[i][nodes.index(node2)] = length
						else:
							L[i][nodes.index(node2)] = min(L[i][nodes.index(node2)], length)
						#reset length for post couner
						length = 0

					elif pre_flag:
						#haven't reached node1 yet
						#reset length
						length = 0
						node2 = position
					else:
						#get length and break
						# print('here2: ', length)
						if L[i][nodes.index(position)] == 0:
							L[i][nodes.index(position)] = length
						else:
							L[i][nodes.index(position)] = min(L[i][nodes.index(position)], length)
						#L[i][nodes.index(position)] = length
						break

					if position == walker.positions[-1]:
						break
				
				length += 1


	# for j in range(len(nodes)):
	# 	node2 = nodes[j]
	# 	length = 0
	# 	if node1 == node2:
	# 		L[i].append(0)
	# 		continue

	# 	for walker in all_walkers:
	# 		if (node1 in walker.positions) and (node2 in walker.positions):
	# 			flag = False
	# 			for position in walker.positions:
	# 				if (position in [node1, node2]) and not flag:
	# 					flag = True
	# 				elif (position in [node1, node2]) and flag:
	# 					length+=1
	# 					flag = False
	# 					break
	# 				elif (position not in [node1, node2]) and flag:
	# 					length+=1
	# 	L[i].append(length)

def print_matrix(matrix):
	for line in matrix:
		to_print = '['
		for el in line:
			element = str(el)
			element = element[:5]
			to_print += f'{element}{" "*(6-len(element))}'
		print(to_print+']')

def print_vector(vector):
	to_print = '['
	for el in vector:
		element = str(el)
		element = element[:5]
		to_print += f'{element}{" "*(6-len(element))}'
	print(to_print+']')

print('L')
print_matrix(L)

D = []	#conductivity
Q = []	#flux
for i in range(len(L)):
	D.append([])
	Q.append([])
	for j in range(len(L[i])):
		if L[i][j] == 0:
			D[i].append(0)
			Q[i].append(0)
		else:
			D[i].append(1)
			Q[i].append(1)


def generate_equation_matrix_and_flux_vector(L, D):

	flux_vector = [0]*len(central_positions)
	equation_matrix = []
	row_count = 0
	for i in range(len(nodes)):
		row_sum = 0
		if nodes[i] not in central_positions:
			#already known, skipping
			continue
		equation_matrix.append([])
		for j in range(len(nodes)):
			if nodes[j] not in central_positions:
				#already known, adding to flux vector
				if L[i][j] == 0:
					pass #not connected to source
				else:
					if nodes[j] in starting_positions:
						flux_vector[row_count] += 0	#0 is the voltage (pressure) here
					else:
						flux_vector[row_count] += pressure*D[i][j]/L[i][j]	#1 is the voltage (pressure) here
					row_sum += D[i][j]/L[i][j]
				continue
			else:
				#unknown, adding to equation matrix
				if L[i][j] == 0:
					equation_matrix[row_count].append(0)
				else:
					equation_matrix[row_count].append(-1*D[i][j]/L[i][j])
					row_sum += D[i][j]/L[i][j]

		equation_matrix[row_count][row_count] = row_sum
		row_count += 1

	equation_matrix = numpy.array(equation_matrix)
	flux_vector = numpy.array(flux_vector)
	# print('EQ')
	# print_matrix(equation_matrix)
	# print('flux: ', flux_vector)
	return equation_matrix, flux_vector



count=0
sum_delta_d = 100
while (count<200) and (sum_delta_d > 0.001):
	sum_delta_d = 0
	count+=1
	equation_matrix, flux_vector = generate_equation_matrix_and_flux_vector(L, D)
	temp_P = list(numpy.linalg.solve(equation_matrix, flux_vector))
	
	P = []
	temp_P_count = 0
	for i in range(len(nodes)):
		if nodes[i] in starting_positions:
			P.append(0)
		elif nodes[i] in finished_positions:
			P.append(pressure)
		else:
			P.append(temp_P[temp_P_count])
			temp_P_count += 1

	# print(count)
	# print_vector(P)

	for i in range(len(L)):
		for j in range(len(L[i])):
			if L[i][j] == 0:
				continue
			Q[i][j] = (D[i][j]/L[i][j])*(P[i]-P[j])

	total_power = 0
	total_absorption = 0
	for i in range(len(nodes)):
		if nodes[i] in finished_positions:
			for j in range(len(nodes)):
				total_power += abs(pressure*Q[i][j])
		for j in range(len(nodes)):
			total_absorption += abs(D[i][j]*L[i][j])

	total_power = total_power*2
	total_absorption = total_absorption

	# print(total_power)
	# print(total_absorption)

	total_energy_gain = 0
	total_energy_loss = 0
	for i in range(len(L)):
		for j in range(len(L[i])):
			if L[i][j] == 0:
				continue 
			energy_gain = Q[i][j]*(P[i]-P[j])/total_power
			total_energy_gain += energy_gain
			energy_loss = D[i][j]*L[i][j]/total_absorption
			total_energy_loss += energy_loss
			delta_d = (energy_gain - energy_loss)*D[i][j]
			sum_delta_d += abs(delta_d)
			D[i][j] += delta_d

			# new_D = (Q[i][j] * (P[i]-P[j])/L[i][j])
			# new_D = 0.5*(Q[i][j] * (P[i]-P[j])/L[i][j] + D[i][j])
			# sum_delta_d += abs(new_D - D[i][j])
			# D[i][j] = new_D
	# print('Q: ', Q)
	# print(total_energy_gain)
	# print(total_energy_loss)
print('D')
print_matrix(D)




#plot results
fig, ax = plt.subplots(1, 1, figsize = (10, 10))
for walker in all_walkers:
	x = []
	y = []
	node2 = walker.positions[0]
	for position in walker.positions:
		x.append(position[0])
		y.append(position[1])
        
		if (position in nodes) and (position != walker.positions[0]):
			#plot segment with width and reset x/y
			width = D[nodes.index(position)][nodes.index(node2)]
			plt.plot(x, y, '-', linewidth=width)
			plt.plot(x[-1], y[-1], 'ro', markersize = 4)
			plt.plot(x[0], y[0], 'bo', markersize = 4)


			x = [position[0]]
			y = [position[1]]
			node2 = position

		if position == walker.positions[-1]:
			#break if last segment
			break

	# plt.plot(x, y, '-')
	# plt.plot(x[-1], y[-1], 'ro', markersize = 4)
	# plt.plot(x[0], y[0], 'bo', markersize = 4)
ax.set_title("Biased walk with chemoattractant".format(), x = 0.5, y = 0.87)
ax.set_xlim(-3000, 5000)
ax.set_ylim(-3000, 3000)
ax.set_xlabel("poisiton in μm")
ax.set_ylabel("poisiton in μm")

#First set color map
mycolor = [[256, 256, 256], [256, 255, 254], [256, 253, 250], [256, 250, 240], [255, 236, 209], [255, 218, 185], [251, 196, 171], [248, 173, 157], [244, 151, 142], [240, 128, 128]] #from coolors：）
for i in mycolor:
    for j in range(len(i)):
        i[j] *= (1/256)
cmap_color = colors.LinearSegmentedColormap.from_list('my_list', mycolor)
m = 8000
conc_matrix = [0]*m    #np.zeros((m, m))
for i in range(m):
    distance_to_nutrient = abs(i - 3000 - nutrient_level)
    noramlized_distance_to_nutrient = 1 - (distance_to_nutrient/nutrient_level)
    exponent = noramlized_distance_to_nutrient * 2 #(noramlized_distance_to_nutrient * (self.nutrient_exponent - self.start_exponent)) + self.start_exponent
    conc_matrix[i] = [exponent + 6]*m
ax.imshow(conc_matrix, cmap=cmap_color, interpolation='nearest', extent = [-3000, 5000, -3000, 5000], origin = 'lower')

plt.show()