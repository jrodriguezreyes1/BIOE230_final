# this takes in the output of the exploration and optimizes it
import os
import numpy
import time
from datetime import datetime
import exploration
import helpers
import matplotlib.pyplot as plt
from matplotlib import colors


def generate_exploration(load_file = None):
	nutrient_level = 1500       # point where nutrient is located

	if load_file == None:
		num_walkers = 5             # Number of Walkers
		x_scaling = 2000            # width of area walkers could be on
		max_loops = 10000           # stop the simulation from running away
		all_walkers, now = exploration.exploration_algorithm(num_walkers, x_scaling, nutrient_level, max_loops)
		plot = exploration.plot_data(all_walkers, nutrient_level)
		exploration_datetime = exploration.save_data(all_walkers, now, plot)
	elif os.path.isfile(load_file):
		all_walkers, nutrient_level, exploration_datetime = helpers.load_exploration(load_file)
	else:
		raise IOError('Load File Not Found')

	return all_walkers, nutrient_level, exploration_datetime


def generate_position_arrays(all_walkers):
	nodes = []
	starting_positions = []
	finished_positions = []
	central_positions = []
	for walker in all_walkers:
		nodes.append(walker.starting_position)
		nodes.append(walker.positions[-1])
		if walker.starting_position[1] == 0:
			starting_positions.append(walker.starting_position)
		else:
			central_positions.append(walker.starting_position)
		if walker.finished:
			finished_positions.append(walker.positions[-1])
		else:
			central_positions.append(walker.positions[-1])

	return nodes, starting_positions, finished_positions, central_positions


def get_post_length(node, walker, nodes):
	length = 0
	counting = False
	for position in walker.positions:
		if counting:
			length += 1
		if counting and (position in nodes):
			node_index = nodes.index(position)
			break
		if position == node:
			counting = True
	return length, node_index

def get_pre_length(node, walker, nodes):
	for position in walker.positions:
		if node == position:
			break
		if position in nodes:
			length = 0
			node_index = nodes.index(position)
		length += 1
	return length, node_index

def generate_length_matrix(all_walkers, nodes):

	L = []
	for i in range(len(nodes)):
		
		node1 = nodes[i]
		L.append([0]*len(nodes))

		for walker in all_walkers:
			if node1 in walker.positions:


				# Really need to test the below code...but works for now
				if node1 == walker.positions[0]:
					#only do after
					length, node_index = get_post_length(node1, walker, nodes)
					L[i][node_index] = length
				elif node1 == walker.positions[-1]:
					#only do before
					length, node_index = get_pre_length(node1, walker, nodes)
					L[i][node_index] = length
				else:
					#do both before and after
					length, node_index = get_post_length(node1, walker, nodes)
					L[i][node_index] = length
					length, node_index = get_pre_length(node1, walker, nodes)
					L[i][node_index] = length

	return L

def initialize_conductance_matrix(L):
	D = []	#conductivity
	for i in range(len(L)):
		D.append([])
		for j in range(len(L[i])):
			if L[i][j] == 0:
				D[i].append(0)
			else:
				D[i].append(1)
	return D


def generate_equation_matrix_and_flux_vector(L, D, central_positions):

	flux_vector = [0]*len(central_positions)
	equation_matrix = []
	row_count = 0
	for i in range(len(nodes)):
		row_sum = 0
		if nodes[i] not in central_positions:
			#already known, skipping
			continue
		equation_matrix.append([])
		for j in range(len(nodes)):
			if nodes[j] not in central_positions:
				#already known, adding to flux vector
				if L[i][j] == 0:
					pass #not connected to source
				else:
					if nodes[j] in starting_positions:
						flux_vector[row_count] += 0	#0 is the voltage (pressure) here
					else:
						flux_vector[row_count] += pressure*D[i][j]/L[i][j]	#1 is the voltage (pressure) here
					row_sum += D[i][j]/L[i][j]
				continue
			else:
				#unknown, adding to equation matrix
				if L[i][j] == 0:
					equation_matrix[row_count].append(0)
				else:
					equation_matrix[row_count].append(-1*D[i][j]/L[i][j])
					row_sum += D[i][j]/L[i][j]

		equation_matrix[row_count][row_count] = row_sum
		row_count += 1

	equation_matrix = numpy.array(equation_matrix)
	flux_vector = numpy.array(flux_vector)

	return equation_matrix, flux_vector


def exploitation_algorithm(L, D, nodes, starting_positions, finished_positions, central_positions, exploration_datetime):

	start_time = time.time()

	previous_energy_transfer = []
	delta_delta_e = 0
	for i in range(len(L)):
		# ys.append([])
		previous_energy_transfer.append([])
		for j in range(len(L)):
			# ys[i].append([])
			previous_energy_transfer[i].append(1)
			delta_delta_e += abs(previous_energy_transfer[i][j])

	count=0
	while (count<500) and (delta_delta_e > 0.001):
		count+=1
		equation_matrix, flux_vector = generate_equation_matrix_and_flux_vector(L, D, central_positions)
		temp_P = list(numpy.linalg.solve(equation_matrix, flux_vector))
		
		P = []
		temp_P_count = 0
		for i in range(len(nodes)):
			if nodes[i] in starting_positions:
				P.append(0)
			elif nodes[i] in finished_positions:
				P.append(pressure)
			else:
				P.append(temp_P[temp_P_count])
				temp_P_count += 1

		Q = []
		for i in range(len(L)):
			Q.append([])
			for j in range(len(L[i])):
				Q[i].append(0)
				if L[i][j] == 0:
					continue
				Q[i][j] = (D[i][j]/L[i][j])*(P[i]-P[j])




		#get total energy in and out of current network
		total_power = 0
		total_absorption = 0
		for i in range(len(nodes)):
			if nodes[i] in finished_positions:
				for j in range(len(nodes)):
					total_power += abs(pressure*Q[i][j])
			for j in range(len(nodes)):
				total_absorption += abs((D[i][j])*L[i][j])

		#update D using contributions to energy gain and loss of each segment
		delta_delta_e = 0
		#previous_energy_transfer = current_energy_transfer
		for i in range(len(L)):
			for j in range(len(L[i])):
				if L[i][j] == 0:
					continue 
				energy_gain = abs(Q[i][j]*(P[i]-P[j]))/total_power
				energy_loss = abs((D[i][j])*L[i][j])/total_absorption

				delta_e = energy_gain - energy_loss
				delta_delta_e += abs(previous_energy_transfer[i][j] - delta_e)
				previous_energy_transfer[i][j] = delta_e

				delta_d = (delta_e)*D[i][j]
				D[i][j] += delta_d
				# ys[i][j].append(D[i][j])

		print(delta_delta_e)

	end_time = time.time()
	print(f'Exploitation time: {round(end_time - start_time, 0)} seconds')

	#log results
	with open('exploitation_log.csv', 'a') as log_file:
		'''
		save simulation parameters to log
		date,time,pressure,absorption_factor,count,exploration_datetime,simulation time, note
		'''
		now = datetime.now()                #get date for saves and logs
		log_file.write(f'{now.strftime("%m/%d/%Y")},{now.strftime("%H:%M:%S")},')    #enter date and time
		log_file.write(f'{pressure},')
		log_file.write(f'{absorption_factor},')
		log_file.write(f'{count},')
		log_file.write(f'{exploration_datetime},')
		log_file.write(f'{end_time - start_time},')
		log_file.write(f'{input("Enter a note for the log file: ")}\n')

	return D, previous_energy_transfer, now




def plot_data(all_walkers, nutrient_level, D):
	#plot results
	fig, ax = plt.subplots(1, 1, figsize = (10, 10))
	for walker in all_walkers:
		x = []
		y = []
		node2 = walker.positions[0]
		for position in walker.positions:
			x.append(position[0])
			y.append(position[1])
	        
			if (position in nodes) and (position != walker.positions[0]):
				#plot segment with width and reset x/y
				width = D[nodes.index(position)][nodes.index(node2)]
				plt.plot(x, y, '-', linewidth=width/10)
				plt.plot(x[-1], y[-1], 'ro', markersize = 4)
				plt.plot(x[0], y[0], 'bo', markersize = 4)


				x = [position[0]]
				y = [position[1]]
				node2 = position

			if position == walker.positions[-1]:
				#break if last segment
				break

	ax.set_title("Biased walk with chemoattractant".format(), x = 0.5, y = 0.87)
	ax.set_xlim(-3000, 5000)
	ax.set_ylim(-3000, 3000)
	ax.set_xlabel("poisiton in μm")
	ax.set_ylabel("poisiton in μm")

	#First set color map
	mycolor = [[256, 256, 256], [256, 255, 254], [256, 253, 250], [256, 250, 240], [255, 236, 209], [255, 218, 185], [251, 196, 171], [248, 173, 157], [244, 151, 142], [240, 128, 128]] #from coolors：）
	for i in mycolor:
	    for j in range(len(i)):
	        i[j] *= (1/256)
	cmap_color = colors.LinearSegmentedColormap.from_list('my_list', mycolor)
	m = 8000
	conc_matrix = [0]*m    #np.zeros((m, m))
	for i in range(m):
	    distance_to_nutrient = abs(i - 3000 - nutrient_level)
	    noramlized_distance_to_nutrient = 1 - (distance_to_nutrient/nutrient_level)
	    exponent = noramlized_distance_to_nutrient * 2 #(noramlized_distance_to_nutrient * (self.nutrient_exponent - self.start_exponent)) + self.start_exponent
	    conc_matrix[i] = [exponent + 6]*m
	ax.imshow(conc_matrix, cmap=cmap_color, interpolation='nearest', extent = [-3000, 5000, -3000, 5000], origin = 'lower')

	return plt

def save_data(D, previous_energy_transfer, now, plot=None):
    #save results
    #make new directory
    os.mkdir(f'exploitation_raw_data\\{now.strftime("%m_%d_%Y")}_{now.strftime("%H-%M-%S")}')

    if plot != None:
        #save plot
        plot.savefig(f'exploitation_raw_data\\{now.strftime("%m_%d_%Y")}_{now.strftime("%H-%M-%S")}\\plot.png')

    #generate and save walker data
    with open(f'exploitation_raw_data\\{now.strftime("%m_%d_%Y")}_{now.strftime("%H-%M-%S")}\\raw_conductivity_data.csv', 'a') as conductivity_file:
        conductivity_file.write(str(D))

    #generate and save walker data
    with open(f'exploitation_raw_data\\{now.strftime("%m_%d_%Y")}_{now.strftime("%H-%M-%S")}\\raw_energy_data.csv', 'a') as energy_file:
        energy_file.write(str(previous_energy_transfer))

if __name__ == '__main__':
	pressure = 100
	absorption_factor = 1

	load_file = "C:\\Users\\couvr\\Documents\\Projects\\Slime_Mold_Simulation\\simulation_software\\exploration_raw_data\\09_03_2023_10-37-18\\raw_data.csv"
	all_walkers, nutrient_level, exploration_datetime = generate_exploration(load_file)
	nodes, starting_positions, finished_positions, central_positions = generate_position_arrays(all_walkers)
	L = generate_length_matrix(all_walkers, nodes)
	D = initialize_conductance_matrix(L)
	D, previous_energy_transfer, now = exploitation_algorithm(L, D, nodes, starting_positions, finished_positions, central_positions, exploration_datetime)

	max_delta_e = 0
	for i in range(len(previous_energy_transfer)):
		for j in range(len(previous_energy_transfer)):
			max_delta_e = max(previous_energy_transfer[i][j], max_delta_e)
	for i in range(len(previous_energy_transfer)):
		for j in range(len(previous_energy_transfer)):
			previous_energy_transfer[i][j] = 250*previous_energy_transfer[i][j]/max_delta_e

	plot = plot_data(all_walkers, nutrient_level, previous_energy_transfer)#D)
	save_data(D, previous_energy_transfer, now, plot)
	plot.show()